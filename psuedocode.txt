
/* 
gameBoard IIFE module:
CAPTION: holds details about the GameBoard and can provide information about its
state. 

MODULE RECEIVES nothing

PRIVATE grid GETS 3x3 array containing null  // null explicitly signals absence of value
SET winningConfigs TO ARRAY OF
    [*,*,*, , , , , , ], 
    [ , , ,*,*,*, , , ],
    [ , , , , , ,*,*,*],
    [*, , ,*, , ,*, , ],
    [ ,*, , ,*, , ,*, ],
    [ , ,*, , ,*, , ,*],
    [*, , , ,*, , , ,*],
    [ , ,*, ,*, ,*, , ]
PRIVATE CONSTANT MARKER_X gets 'x'
PRIVATE CONSTANT MARKER_O gets 'o'
PRIVATE CONSTANT TIE gets 'tie'
PRIVATE CONSTANT ONGOING gets 'ongoing;

PRIVATE winner GETS null;
PRIVATE numMarks GETS 0

PUBLIC FUNC isBlank RECEIVES indices i,j RETURNS if specified cell is null
PUBLIC FUNC placeMark RECEIVES indices i,j and marker DOES
    IF isBlank(i,j)  // a check happens here but the game controller should check as well
        PUT marker in grid[i][j] 
        INCREMENT numMarks
    ELSE
        THROW ERROR

    RETURNS nothing

// Returns one of: 'x', 'o', TIE or ONGOING
PUBLIC FUNC getGameState RECEIVES nothing DOES
    CALL getGameWinner and store result
    IF result non-null: RETURN the winning marker
    ELSE: CALL isTie and RETURN either TIE or ONGOING
    
PRIVATE FUNC getGameWinner RECEIVES nothing DOES
    CHECK if either marker has won by comparing against winningConfigs
    IF neither won, winner will be null
    RETURNS one of MARKER_X, MARKER_O, or null

PRIVATE FUNC isTie RECEIVES nothing DOES // a tie is defined as board filled and no winner
    IF (winner is null) AND (numMarks === 9) RETURN TRUE
    ELSE RETURN FALSE

PUBLIC FUNC resetBoard RECEIVES nothing DOES
    FOR EACH cell IN grid, PUT null
    SET numMarks to 0

RETURN as module:
    the public stuff
*/


/*
CreatePlayer factory function:
CAPTION:

RECEIVES: playerName, playerMarker

PRIVATE name = playerName;
PRIVATE marker = playerMaker

PUBLIC FUNC getName () {
    RETURNS name
}
PUBLIC FUNC getMarker () {
    RETURNS marker
}
// no setters since don't want these properties to be modified

// ? just an idea
PUBLIC FUNC requestMark(i, j) {

}

RETURN {
    the public stuff
}
*/


/*
GameControl IIFE module:
CAPTION: Logic responsible for allowing players to make a choice, calling GameBoard's methods. 
will print to console in the console version of the game. 
MODULE RECEIVES nothing (no dependencies)

PRIVATE let player1;
PRIVATE let player2;

// holds null, 1, or 2. null acts as a proxy for a game not being in session
PRIVATE let playerTurn = null; 

PRIVATE FUNC hasGameBegun ACCEPTS nothing
    RETURNS whether playerTurn IS NOT null

// called when pressing the [Start Game] button
PUBLIC FUNC createPlayers ACCEPTS name1, name2 RETURNS nothing
    CHECK if game is ongoing by CALLING hasGameBegun
        THROW error if so
    CHECK if player1 or player2 are already defined
        THROW error if so

    SET player1 & player2 BY CALLING createPlayer factory function

// called to start a new game once players are created (click [Begin!] on player creation screen)
PUBLIC FUNC playGame ACCEPTS nothing RETURNS nothing
    CHECK if players are created: if player1 or player2 are undefined
        THROW error if so
    CHECK if game IS ongoing by CALLING hasGameBegun
        THROW error if so
    
    RESET the gameBoard by CALLING gameBoard.resetBoard
    SET playerTurn TO 1

PUBLIC FUNC playTurn ACCEPTS coordinates i,j RETURNS the marker placed or error if unable to
    CHECK if game IS NOT ongoing by CALLING hasGameBegun
        THROW error if so
    check if coordinate is valid: in range? does it collide? (use Gameboard.isBlank(i,j))
        THROW error

    // place mark
    SET mark to x or o depending on playerTurn
    CALL Gameboard.placeMark(i,j,mark)

    // Check the gamestate and handle a conclusion if applicable
    CALL Gameboard.getGamestate()
    IF 'ongoing',
        SET playerTurn to either 1 or 2 (toggle)
    ELSE (game has concluded),         
        CALL showConclusion PASSING IN the conclusion
        CALL concludeGame

PRIVATE FUNC showConclusion ACCEPTS one of 'xWin', 'oWin', 'tie' (as defined by Gameboard) RETURNS nothing
    IF not a valid conclusion:
        THROW error

    LOG a message displaying the conclusion

PRIVATE FUNC concludeGame ACCEPTS nothing RETURNS nothing
    SET playerTurn TO null // disables playTurn from being called until playGame is called again
    (does not reset the player)
    (does not reset the grid)

*/

/*
GameDisplay IIFE module:
CAPTION: Provides means for user to interact with the game. Makes calls to 
GameControl based on user input.  
MODULE RECEIVES nothing (no dependencies)

per specs:
Write a function that will render the contents of the gameboard array to the 
webpage (for now, you can always just fill the gameboard array with "X"s and 
"O"s just to see whatâ€™s going on).

// lets do this first so i can see the game that's going on when i play in console
FUNC displayGrid ACCEPTS nothing DOES:
    GET a copy of the grid from gameBoard (should be a copy)
    FOR i,j in the grid:
        SELECT the grid cell with matching data-i and data-j
        SET its text content to x, o, or ""

FUNC handleCellClick ACCEPTS click event RETURNS 
    TRY
        CALL gameControl.playTurn(i,j)
        CALL displayGrid to update the display
    CATCH  
        DISPLAY a message in #alert-box saying it's occupied and to try again
    
    

ADD EVT LISTENER to ['Start game'] CALL showModal() on dialog #create-players-dialog
ADD EVT LISTENER to ['Begin!] CALL:
    gameControl.createPlayers(the names)
    REMOVE ['Start game'] from the DOM
    ADD ['Restart game'] in place of ['Start game']
    ADD EVT LISTENER to ['Restart game'] CALL gameControl.end() and gameControl.playGame()
    ADD "turn" display to the top left populated with p1name and symbol

ADD EVT LISTENER to the grid listening for which cell is selected using the data-* attributes:
    if requests a blank space:
        ADD a symbol in that space (might need to have access to gameControl's turn variable)
        CALL gameControl.playTurn(i,j)
        if gameState is ongoing:
            TOGGLE the turn display
        else:
            activate ending modal by calling .showModal()
    else (requests an occupied space):
        DISPLAY a transient message notifying that space is occupied 

ADD EVT LISTENER to the ending modal's ['Play-again'] button:
    CALL gameControl.playGame()
    close modal

*/

/*
HTML

button ['Start game'] with id=open-player-creation
dialog with id=create-players-dialog CONTAINS:
    inputs for the player names
    button ['Begin!'] with id=create-players
    button ['Cancel'] to close the modal

// tictactoe grid
div with grid layout 3x3 containing cells:
    each with attributes "data-i" and "data-j" 
    and some pixel gap between them

top left: div with a 'turn' indicator and player name & marker

below grid: a hidden div that displays if a space is occupied.

dialog with id=end-screen-dialog CONTAINS
    result message
    player scores
    button ['Play again?'] with id=play-again
    button ['Close'] to close the modal


*/